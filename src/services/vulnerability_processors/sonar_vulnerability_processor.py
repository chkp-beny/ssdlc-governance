"""
SonarVulnerabilityProcessor - Extract SonarQube vulnerability processing logic from Product class

This module handles SonarQube vulnerability and code quality data processing for products.
Extracted from the Product class to provide specialized vulnerability processing capabilities.
"""

import os
import logging
from typing import List

logger = logging.getLogger(__name__)


class SonarVulnerabilityProcessor:
    """Processes SonarQube vulnerability and code quality data for repositories"""
    
    def __init__(self, product_name: str, organization_id: str):
        """
        Initialize SonarVulnerabilityProcessor
        
        Args:
            product_name (str): Product name for configuration lookup
            organization_id (str): Organization ID for API calls
        """
        self.product_name = product_name
        self.organization_id = organization_id
        self.compass_client = None
        self._initialize_compass_client()
    
    def _initialize_compass_client(self):
        """Initialize CompassClient with credentials from environment"""
        try:
            from src.services.compass_client import CompassClient
            compass_token = os.getenv('COMPASS_ACCESS_TOKEN', '')
            compass_url = os.getenv('COMPASS_BASE_URL', '')
            
            if not compass_token or not compass_url:
                logger.warning("Compass credentials not found in environment variables")
                return
            
            self.compass_client = CompassClient(compass_token, compass_url)
            logger.debug("CompassClient initialized for SonarVulnerabilityProcessor")
            
        except ImportError as e:
            logger.error("Failed to import CompassClient: %s", str(e))
    
    def process_vulnerabilities(self, repositories: List) -> int:
        """
        Load SonarQube vulnerability data for repositories
        
        Args:
            repositories (List): List of repository objects to update
            
        Returns:
            int: Number of repositories updated with vulnerability data
        """
        if not self.compass_client:
            logger.warning("No CompassClient available, skipping Sonar vulnerability processing")
            return 0
        
        try:
            # Fetch SonarQube issues and secrets data
            sonar_issues = self.compass_client.fetch_sonarqube_issues(self.organization_id)
            if not sonar_issues:
                logger.info("No SonarQube issues data returned for organization '%s'", self.organization_id)
                return 0
            
            sonar_secrets = self.compass_client.fetch_sonarqube_secrets(self.organization_id)
            logger.info("Fetched SonarQube secrets data for %d projects", len(sonar_secrets))
            
            updated_count = 0
            
            # Get Sonar prefix for this product
            sonar_prefix = self._get_sonar_prefix()
            
            # Process SonarQube issues data
            for project_key, issues_data in sonar_issues.items():
                repo_name = self._extract_repo_name_from_project_key(project_key, sonar_prefix)
                
                # Find matching repository
                matching_repo = self._find_matching_repository(repositories, repo_name)
                
                if matching_repo:
                    # Process and update repository with Sonar issues and secrets
                    if self._process_sonar_issues(matching_repo, issues_data, sonar_secrets, project_key):
                        updated_count += 1
            
            logger.info("Updated Sonar code issues data for %d repositories in product '%s'", 
                       updated_count, self.product_name)
            return updated_count
            
        except (ValueError, KeyError, OSError) as e:
            logger.error("Error loading Sonar code issues data for product '%s': %s", self.product_name, str(e))
            return 0
    
    def _get_sonar_prefix(self) -> str:
        """Get Sonar prefix for this product from constants"""
        try:
            from CONSTANTS import PRODUCT_SONAR_PREFIX
            return PRODUCT_SONAR_PREFIX.get(self.product_name, "")
        except ImportError:
            import sys
            sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
            from CONSTANTS import PRODUCT_SONAR_PREFIX
            return PRODUCT_SONAR_PREFIX.get(self.product_name, "")
    
    def _extract_repo_name_from_project_key(self, project_key: str, sonar_prefix: str) -> str:
        """Extract repository name from SonarQube project key"""
        if sonar_prefix and project_key.startswith(sonar_prefix):
            repo_name = project_key[len(sonar_prefix):]
            # Handle case where separator is included in prefix
            if repo_name.startswith('-'):
                repo_name = repo_name[1:]
            return repo_name
        else:
            # No prefix or prefix doesn't match, use project key as-is
            return project_key
    
    def _find_matching_repository(self, repositories: List, repo_name: str):
        """Find repository that matches the given name"""
        for repo in repositories:
            if repo.get_repository_name() == repo_name:
                return repo
        return None
    
    def _process_sonar_issues(self, repository, issues_data: dict, sonar_secrets: dict, project_key: str) -> bool:
        """Process SonarQube issues and secrets for a repository"""
        try:
            from src.models.vulnerabilities import Vulnerabilities, CodeIssues
            
            # Initialize vulnerabilities if not already initialized
            if repository.vulnerabilities is None:
                repository.vulnerabilities = Vulnerabilities()
            
            # Process all issue types dynamically (VULNERABILITY, CODE_SMELL, BUG, etc.)
            issues_by_type = {}
            
            # Iterate through all issue types in the response
            for issue_type, type_data in issues_data.items():
                if 'issues' in type_data:
                    severity_counts = type_data['issues']
                    issues_by_type[issue_type] = severity_counts
                    
                    logger.debug("Collected '%s' issues for repo '%s': %s", 
                               issue_type, repository.get_repository_name(), severity_counts)
            
            # Update the repository's code issues with all types
            if issues_by_type:
                # Check if we have secrets data for this project
                secrets_count = self._extract_secrets_count(sonar_secrets, project_key)
                
                # Create or update CodeIssues with all collected issue types and secrets
                repository.vulnerabilities.code_issues = CodeIssues(issues_by_type, secrets_count)
                
                logger.debug("Updated code issues for repo '%s' with %d issue types and %d secrets: %s", 
                           repository.get_repository_name(), len(issues_by_type), secrets_count, list(issues_by_type.keys()))
                return True
            
        except Exception as e:
            logger.error("Error processing Sonar issues for repository '%s': %s", 
                        repository.get_repository_name(), str(e))
        
        return False
    
    def _extract_secrets_count(self, sonar_secrets: dict, project_key: str) -> int:
        """Extract secrets count from SonarQube secrets data"""
        secrets_count = 0
        if sonar_secrets and project_key in sonar_secrets:
            secrets_data = sonar_secrets[project_key]
            # Extract secrets count from the response
            if isinstance(secrets_data, dict):
                secrets_count = secrets_data.get('secrets_count', 0)
            elif isinstance(secrets_data, int):
                secrets_count = secrets_data
            
            logger.debug("Found %d secrets for project '%s'", secrets_count, project_key)
        
        return secrets_count
